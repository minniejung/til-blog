import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'
import { vscDarkPlus } from 'react-syntax-highlighter/dist/esm/styles/prism'

import { TilCardType } from '../types'

export const dataBlockchain: TilCardType[] = [
	{
		id: 0,
		date: '03/02/2025',
		tags: ['Cypherpunk', 'Privacy', 'Genesie block', 'Bitcoin', 'Pizza day', 'Blockchain'],
		title: 'BITCOIN & BLOCKCHAIN',
		content: (
			<div>
				<h3>Cypherpunk&#39;s Manifesto (1993, Eric Hughes)</h3>
				<pre>
					{`- 프라이버시는 기본적인 인간의 권리
  * 개인이 자신의 정보를 자유롭게 통제할 수 있어야 한다.
  * 감시 없는 자유로운 사회를 위해 필수적이다.

- 정부와 기업의 감시 위험
  * 온라인 활동이 추적, 기록, 분석되면서 개인의 자유가 침해된다.
  * 중앙집중화된 데이터 관리 구조는 위험하다.

- 해결책은 암호화 기술
  * 법이나 제도가 아니라 강력한 암호화 기술(Encryption) 만이 프라이버시를 보장할 수 있다.
  * 정보는 암호학을 통해 보호되어야 하며, 이는 누구나 사용할 수 있어야 한다.

- 탈중앙화가 핵심
  * 중앙기관을 신뢰할 필요 없는 P2P(개인 간) 시스템을 구축해야 한다.
  * 개인이 자신의 데이터를 직접 소유하고 관리해야 한다.

- "Cypherpunks write code"
  * 말이 아니라 직접 기술을 만들어야 한다.
  * PGP 암호화, Tor 네트워크, 블록체인(Bitcoin) 같은 도구가 핵심이다.

- 영향 및 유산
  * 비트코인과 블록체인 탄생에 기여 (검열 없는 탈중앙 금융)
  * 암호화된 커뮤니케이션 도구 발전 (PGP, Signal, Tor)
  * Web3, 프라이버시 기술, 디지털 권리 운동의 기반 철학 제공
`}
				</pre>

				<h3>Bitcoin의 등장</h3>
				<pre>
					{`- 세계 금융 위기가 발생한 2008년 10월 31일. 사이퍼 펑크 메일링 리스트에 "Bitcoin P2P e-cash paper" 라는 이름의 메일이 등장
- 9쪽 짜리의 비트코인 백서("Bitcoin: A Peer-to-Peer Electronic Cash System")와 비트코인이 세상에 처음으로 등장
`}
				</pre>

				<h3>Genesis Block</h3>
				<pre>
					{`- 2009년 1월. 첫 번째 블록(제네시스 블록) 채굴을 시작으로 소스 코드 공개와 함께 비트코인 등장

- 중앙화 금융 시스템에 대한 비판
  * 중앙은행과 정부가 주도하는 중앙화된 금융 시스템의 불안정성과 문제점을 비판
  * 금융위기 당시 은행들이 무분별한 투자를 했음에도 불구, 실패의 책임을 국민이 떠안아야 한다는 구조에 강한 문제의식을 가짐

- 탈 중앙화 금융의 대안 제시
  * 비트코인은 중앙 기관 없이 작동하는 탈중앙화 디지털 화폐로 설계되었으며, 이를 통해 기존 금융 시스템의 문제를 극복하고자 함
  * 메시지를 통해 비트코인의 철학(탈중앙화, 신뢰 없는 시스템)을 상징적으로 드러냄

- 역사적 맥락을 기록
  * 제네시스 블록에 메시지를 포함함으로써, 비트코인이 어떤 문제를 해결하려는 목적으로 탄생했는지를 명확히 전달
  * 비트코인의 기원이 글로벌 금융위기의 한복판에서 비롯되었음을 명시적으로 기록
`}
				</pre>

				<h3>Pizza day (2010. 5. 22)</h3>
				<pre>
					{`- 라스즐로 핸예츠(Laszlo Hanyecz)라는 프로그래머가 비트코인을 이용해 처음으로 피자 2판을 구매
- 비트코인을 사용한 최초의 실물 거래
- 비트코인이 화폐로써 기능을 할 수 있음을 인식하는 계기가 됨
`}
				</pre>
			</div>
		),
	},
	{
		id: 1,
		date: '04/02/2025 (1)',
		tags: ['Hash', 'SHA-256', 'Public key', 'Private key', 'Bitcoin', 'Blockchain'],
		title: 'HASH',
		content: (
			<div>
				<h3>Q. 해시(Hash)란?</h3>
				<pre>
					{`A. 데이터를 압축하고 고정된 크기의 출력값. 주로 데이터의 무결성을 확인하거나 암호학적 보안을 제공하는 데 사용.

[타임 스탬프 해시 생성 과정]
  데아터 준비 -> 데이터를 고정된 길이의 해시 값으로 변환 -> 해시 값을 타임스탬프 기관(TSA, Timestamp Authority)에 제출
  -> TSA가 사용자가 제출한 해시 값 + 타임 스탬프 + 서명을 추가한 결과를 반환 -> 데이터 검증
`}
				</pre>

				<h3>Q. 해시 함수의 특징?</h3>
				<pre>
					{`A. 입력 데이터의 크기와 관계없이 고정된 길이 (e.g. SHA-256는 256비트(32바이트))
   서로 다른 입력 데이터가 동일한 해시 값을 가지는 가능성은 극히 낮음
   역으로 계산하는 것은 불가능
   현대 컴퓨터에서 빠른 계산이 가능
   현재까지는 실질적인 공격/충돌 생성이 매우 어려움
`}
				</pre>

				<h3>Q. 해시 함수의 활용?</h3>
				<pre>
					{`A. 블록체인 - 암호화폐의 데이터 무결정을 보장하고 체인 연결하는 데 사용
   디지털 서명 - 데이터 인증 및 무결성 확인
   암호화 저장 - 비밂번호 및 중요한 데이터를 안전하게 저장
   데이터 검증 - 파일 다운로드 및 전송 중 데이터 손상 여부 확인 가능
`}
				</pre>

				<h3>Q. SHA-256 알고리즘 작동 과정?</h3>
				<pre>
					{`A. 입력 데이터 준비 (512비트 블록으로 처리 됨)
   -> 부족한 비트를 채우기 위해 패딩 추가 (1을 추가 후 데이터 길이가 512비트의 배수가 될때까지 0을 추가, 그리고 길이정보 추가)
   -> SHA-256의 8개의 32비트 초기 해시 값과 함께 라운드 연산을 통해 최종 해시 값 출력
`}
				</pre>

				<h3>Q. 블록 해시 값 생성 인자는?</h3>
				<pre>
					{`A. Version, Prev block hash, Merkle root, Timestamp, Difficulty target, Nonce

PoW 작업 증명을 위해 채굴자들은 Nonce랑 Timastamp를 MerKle root를 계속해서 수정해 가며 퍼즐을 풀어야 함
e.g. 000000000000000000015ac6f0b07acb480cff6a6fd389350398cbe8455994a9
     블록 해쉬의 0의 개수가 많을 수록 난이도가 높음
[
`}
				</pre>

				<h3>[대칭키 암호화]</h3>
				<pre>
					{`- 대칭키는 암호화와 복호화에 모두 사용됨
  - 평문 데이터를 입력받아 비밀 키를 사용하여 암호문으로 변환
  - 암호문은 안전하지 않은 네트워크를 통해 수신자에게 전송 됨
  - 비밀 키를 아는 사람만 암호문을 복호화할 수 있습니다.
  - 수신자가 동일한 비밀 키를 사용하여 암호문을 평문으로 복호화합니다.

    e.g. 개발팀 환경셋팅, 금고 열쇠, 공용 비밀번호
`}
				</pre>

				<h3>[비대칭키 암호화]</h3>
				<pre>
					{`- 공개키(PublicKey) 와 개인키(비밀키, PrivateKey) 를 한 쌍으로 사용되는 암호화 방식
  - 개인키 생성 후, 개인 키로부터 공개 키를 생성 (개인 키에서 공개 키는 유추 가능하나 반대로는 불가)

    e.g. 디지털 서명(트랜잭션 서명 등)
`}
				</pre>

				<h3>[공개 키로 암호화 (Encryption using Public Key)]</h3>
				<pre>
					{`- 공개 키로 암호화 할 시, 대항 데이터를 복호화 할 수 있는 사람은 오직 해당 개인 키를 가진 사용자 뿐
- 블록체인에서는 데이터의 기밀성을 보장하기 위해 공개 키로 암호화하는 방식은 자주 사용되지는 않음
- 동작원리 : 송신자가 수신자의 공개 키로 데이터를 암호화 -> 수신자는 자신의 개인키로 데이터를 복호화
`}
				</pre>

				<h3>[개인 키로 암호화 (Encryption/Signing using Private Key)]</h3>
				<pre>
					{`- 디지털 서명
      1. 송신자가 자신의 개인 키로 데이터를 서명 ->
      2. 서명된 데이터는 수신자에게 전송 ->
      3. 수신자는 서명된 데이터와 발신자의 공개 키를 사용해 서명을 검증 ->
      4. 이를 통해 데이터가 발신자로부터 생성되었고 중간에 변경되지 않았음을 증명
`}
				</pre>
			</div>
		),
	},
	{
		id: 2,
		date: '04/02/2025 (2)',
		tags: ['Digital Signature', 'Timestamp', 'Bitcoin', 'Blockchain'],
		title: 'DIGITAL SIGNATURE',
		content: (
			<div>
				<h3>[디지털 서명]</h3>
				<pre>
					{`- 서명의 역할은 문서의 진위성과 무결성을 보증하는 것
- 디지털 서명은 개인 키(Private Key)를 사용하여 생성
- 개인 키로 데이터를 서명함으로써, 서명의 주체가 ‘나’라는 것을 인증할 수 있으며, 이 데이터가 변조되지 않았음을 증명

- 디지털 서명된 데이터를 수신한 사용자는 공개 키(Public Key)를 사용해 서명을 검증하며 서명과 데이터가 일치하는지를 확인
      1. 데이터의 무결성 : 데이터가 전송 중 변조되지 않았는지
      2. 진위성 확인 : 데이터를 서명한 사람이 신뢰할 수 있는 발신자인지
      3. 부인 방지 : 송신자의 개인키가 안전하게 보관되었다는 전제하에, 서명 생성 후에는 이 서명이 송신자에 의해 서명되었다는 사실을 부정할 수 없음
`}
				</pre>

				<h3>[디지털 서명의 장점]</h3>
				<pre>
					{`- 보안성: 개인 키가 노출되지 않는 한, 다른 사용자가 서명을 위조할 수 없음
- 무결성 보장: 트랜잭션 데이터가 변조될 경우, 서명이 유효하지 않게 됨
- 부인 방지: 송신자는 자신이 해당 트랜잭션에 서명했음을 부정할 수 없음
- 신뢰 기반 탈중앙화: 디지털 서명은 중앙 기관 없이도 트랜잭션의 신뢰성을 보장
`}
				</pre>

				<h3>[타임스탬프에서의 디지털 서명의 사용 목적]</h3>
				<pre>
					{`- 무결성 증명 : 데이터가 특정 시점 이후로 변경되지 않았음을 보장, 디지털 서명을 통해 변조되지 않았음을 검증
- 시간 인증 :  데이터가 특정 시간에 존재했음을 증명, 타임스탬프 인증 기관이 디지털 서명을 통해 해당 시간에 데이터를 인증
- 신뢰 제공 : 디지털 서명은 인증 기관의 신뢰를 바탕으로 데이터의 진위를 보증
`}
				</pre>

				<h3>[비트코인에서 디지털 서명의 역할]</h3>
				<pre>
					{`- 트랜잭션 무결성 증명 : 트랜잭션 데이터가 변경되지 않았음을 보장
- 소유권 증명 : 트랜잭션을 생성한 사용자가 해당 비트코인의 소유자임을 증명
- 탈중앙화된 검증 : 디지털 서명을 검증하여 트랜잭션의 유효성을 확인, 중앙 기관 없이 신뢰를 유지할 수 있도록 함
`}
				</pre>
			</div>
		),
	},
	{
		id: 3,
		date: '05/02/2025 (1)',
		tags: ['Block', 'Block header', 'Merkle root', 'Timestamp', 'Nonce', 'Bitcoin', 'Blockchain'],
		title: 'BLOCK',
		content: (
			<div>
				<h3>[Block Header]</h3>
				<pre>
					{`- 블록에 대한 메타데이터를 포함하고 있으며, 블록의 고유 식별자 역할을 함
- 크기는 80바이트로 고정
`}
				</pre>

				<h3>[Block Header 구성요소]</h3>
				<pre>
					{`- Previous Block Hash
    * 이전 블록의 해시 값으로 블록 간 연결성을 제공
    * 체인을 형성하며 블록체인의 무결성을 보장

- Merkle Root
    * 블록에 포함된 모든 트랜잭션의 해시를 결합하여 생성된 트리의 루트 해시 값
    * 블록 내 모든 트랜잭션이 변경되지 않았음을 증명

- Timestamp
    * 블록이 생성된 시간
    * UNIX 타임스탬프 형식(초 단위)
    * 1970년 1월 1일 00:00:00 UTC(세계 협정시)로부터 경과한 초 단위의 정수로 표현하는 방식
    e.g. 1704531060 (2025년 1월 6일 오후 3시 31분 0초 UTC)

- Difficulty Target
    * 현재 블록 생성 난이도
    * 네트워크의 작업 증명(Proof of Work) 목표를 정의

- Nonce
    * 작업 증명에서 정답을 찾기 위해 변경되는 값
    * 올바른 블록 해시를 찾기 위해 마이너가 반복적으로 시도

- Version
    * 블록이 사용하고 있는 비트코인 프로토콜의 버전 정보
`}
				</pre>

				<h3>[Block Body]</h3>
				<pre>
					{`- 블록에 포함된 트랜잭션 데이터를 저장
`}
				</pre>

				<h3>[Block Body 특징]</h3>
				<pre>
					{`- 코인베이스 트랜잭션 (Coinbase Transaction)
    * 블록을 생성한 마이너에게 보상이 지급되는 트랜잭션
    * 항상 블록의 첫 번째 트랜잭션으로 포함

- 일반 트랜잭션 (Transactions)
    * 블록에 포함된 모든 비트코인 전송 기록
    * 트랜잭션의 개수는 네트워크의 상태와 트랜잭션 용량에 따라 달라짐
`}
				</pre>
			</div>
		),
	},
	{
		id: 4,
		date: '05/02/2025 (2)',
		tags: ['Transaction', 'ScriptSig', 'ScriptPubKey', 'Merkel Tree', 'Blockchain'],
		title: 'TRANSACTION',
		content: (
			<div>
				<h3>[Transaction]</h3>
				<pre>
					{`- 트랜잭션 구조는 송금 요청을 기록하고 검증하기 위해 사용되는 데이터 구조
- 입력(Input)과 출력(Output)으로 구성되며, 각 트랜잭션의 상세내용 포함
- 비트코인의 경우 현재 한 블록 당 최대 4MB의 데이터를 처리할 수 있음. (블록 헤더가 80바이트 (고정 크기), 트랜잭션 데이터는 나머지 공간(1MB 또는 4MB) 차지)
`}
				</pre>

				<h3>[Transaction 구성요소]</h3>
				<pre>
					{`- Version
    * 트랜잭션의 형식을 정의하는 숫자 필드
    * 현재 사용 중인 비트코인 버전은 2 또는 1
    * 크기: 4바이트

- Input
    * 입력은 트랜잭션이 사용하는 이전 트랜잭션의 출력(UTXO: Unspent Transaction Output)을 참조
    * 입력은 송신자의 서명이 포함된 정보

    [Input 구성 요소]
        A. Transaction Hash : 현재 트랜잭션이 참조하는 이전 트랜잭션의 해시 값. (크기: 32바이트)
        B. Output Index : 참조하는 트랜잭션에서 어떤 출력(0부터 시작하는 인덱스)을 사용하는지를 나타내는 UTXO (크기: 4바이트)
        C. Script Length : 잠금 해제 스크립트(Unlocking Script, ScriptSig)의 길이 (크기: 가변)
        D. ScriptSig : 이전 트랜잭션 출력의 소유권을 증명하기 위한 서명과 공개키로 구성된 스크립트
                        (공개키와 디지털 서명 포함)
        E. Sequence Number : 트랜잭션이 취소되거나 수정될 가능성을 나타내는 필드로, 현재는 거의 사용되지 않음 (크기: 4바이트)

- Output
    * 출력은 수신자에게 전달되는 비트코인의 정보를 포함
    * 한 트랜잭션은 여러 개의 출력을 가질 수 있음

    [Output 구성 요소]
        A. 출력 금액(Value) : 해당 출력에 포함된 비트코인의 금액 (단위: 사토시(1 비트코인 = 10^8 사토시) / 크기: 8바이트)
        B. 스크립트 길이(Script Length) : 잠금 스크립트(Locking Script, ScriptPubKey)의 길이 (크기: 가변)
        C. 잠금 스크립트(ScriptPubKey) : 비트코인을 잠금(수신자의 주소를 설정)하는 스크립트
                                일반적으로 P2PKH(Pay-to-Public-Key-Hash) 스크립트 형식을 사용, 수신자의 주소를 포함

- Transaction Counter
    * 트랜잭션이 포함된 입력(Input)과 출력(Output)의 개수를 기록
    * 각각 입력 개수와 출력 개수를 별도로 저장하며, 네트워크가 각 트랜잭션의 크기를 빠르게 파악할 수 있게 함
    * 크기: 가변(1바이트 이상, 비트코인 직렬화 규칙에 따라 다름)

- Lock Time
    * 해당 트랜잭션이 유효해지는 조건
    * 특정 블록 높이 또는 타임스탬프가 설정될 수 있으며, 이 조건이 충족되어야 트랜잭션이 유효함
    * 크기: 4바이트
`}
				</pre>

				<h3>[잠금 스크립트와 해제 스크립트 예시]</h3>
				<pre>
					{`- P2PKH는 비트코인의 트래잭션 유형으로 "공개키(해시값)에 비트코인을 보내겠다.(Pay-to-Public-Key-Hash)"라는 형식
    * ScriptSig (잠금 해제 스크립트): 입력에서 사용되며, 이전 트랜잭션 출력의 소유권을 증명하기 위해 사용
    * ScriptPubKey (잠금 스크립트): 출력에서 사용되며, 수신자에게 비트코인을 보낼 주소를 지정

- ScriptPubKey (P2PKH 형식):
    OP_DUP OP_HASH160 <Recipient's Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
- ScriptSig (서명 및 공개키):
    <Signature> <Public Key>
`}
				</pre>

				<h3>[Merkel Tree]</h3>
				<pre>
					{`- 여러 데이터에 대해 단계적인 해시 함수를 적용하여 최종적으로 머클 루트하는 하나의 최상단 해시값을 생성하는 데이터 구조
- 데이터의 무결성을 보장하고 위변조를 방지하기 위해 사용
- 최종 해시 값은 더블 해싱 SHA-256(SHA-256(Block Header Data))
- 최종 해시값이 바로 머클 루트가 되며, 블록의 헤더에 들어가게 됨

- 한 블록이 악의적으로 수정되거나 변조되면 이후의 모든 블록의 해시 값을 다시 계산해야 함
- 악의적인 노드가 변경된 체인이 전파되더라도, 네트워크 전체 노드의 51% 이상에 해당하는 컴퓨팅 파워를 확보하지 않는 한 무효로 간주
`}
				</pre>
			</div>
		),
	},
	{
		id: 5,
		date: '05/02/2025 (3) ',
		tags: ['UTXO', 'bitcoin 명령어', 'Blockchain'],
		title: 'UTXO',
		content: (
			<div>
				<h3>What is an UTXO(Unspent Transaction Output) ?</h3>
				<pre>
					{`- 트랜잭션에서 생성되었지만 아직 소비되지 않은 출력
- 비트코인 네트워크에서 사용자의 잔고와 트랜잭션을 추적하는 기본 단위

- UTXO의 역할
    * 잔고 관리 : 해당 사용자가 소유한 UTXO의 합계 = 사용자가 보유한 비트코인의 총량
    * 트랜잭션 검증 : UTXO는 트랜잭션의 입력으로 참조되며, 이미 소비된 UTXO는 다시 사용할수 없으므로 이중지불을 방지

- UTXO의 생성
    * 트랜잭션의 출력으로 새 UTXO 생성
    * 이 출력은 비트코인 주소로 잠겨 있으며, 해당 주소 소유자만 UTXO를 소비할 수 있음

- UTXO의 소비
    * 트랜잭션의 입력은 기존 UTXO를 참조하여 소비
    * 소비된 UTXO는 더 이상 유효하지 않으며 새로운 UTXO가 생성

- UTXO의 구조
    * 금액 : 해당 UTXO에 저장된 비트코인의 양(단위:사토시)
    * 소유자 정보 : 트랜잭션 스크립트 형태로 저장된 소유자 정보
    * 트랜잭션 ID : UTXO를 생성한 트랜잭션 고유 식별자(TxID)
    * 출력 인덱스 : 해당 트랜잭션에서 이 UTXO가 몇 번째 출력인지를 나타내는 번호

- UTXO의 장단점
    * 장점 : 보안성 - 이중 지불을 방지하고 네트워크 무결성을 보장
            독립적인 UTXO를 사용하면 병렬로 트랜잭션을 처리할 수 있음
    * 단점 : 복잡한 잔돈 관리 : 트랜잭션마다 잔돈 UTXO가 새로 생성되므로 UTXO 세트가 빠르게 증가
            저장소 부담 : 전체 네트워크의 UTXO 데이터를 유지하는 상당한 저장소가 필요

(+) UTXO는 비트코인 고유의 방식. 비트코인에서는 반복분 사용이 불가, 이더는 가스비를 쓰게 만들어서 공격을 힘들게 함
`}
				</pre>

				<pre>
					{`(+) bitcoin 명령어

  * getblockchaininfo : 비트코인 설정 파일 확인
  * createwallet : 지갑 주소 생성
  * getnewaddress : 지갑 주소 확인
  * getbalance : 잔액 확인
  * generatetoaddress 101 (복사한 지갑 주소) : 블록 생성(채굴)
  * listunspent : 유효한 UTXO 확인
  * listreceivedbyaddress 0 true : 내 주소들/잔고 확인
  * sendtoaddress <받는 주소> <금액> : 비트코인 송금
  * gettransaction (트랜잭션 ID) : 트랜잭션 상태 확인

사용방법 : bitcoin-cli -conf=(비트코인 데이터 디렉토리 경로)/bitcoin.conf 명령어
`}
				</pre>
			</div>
		),
	},
	{
		id: 6,
		date: '06/02/2025 (1) ',
		tags: ['Ledger', 'Distributed ledger', 'Blockchain'],
		title: 'DISTRIBUTED LEDGER',
		content: (
			<div>
				<h3>Q. What is a Ledger in Blockchain?</h3>
				<pre>
					{`A. A ledger in blockchain is a digital record-keeping system that stores all transactions in a decentralized and immutable manner.

Ledger : 거래, 소유권, 자산 등 다양한 데이터와 정보를 기록하고 관리하는 시스템. 전통적으로는 종이 기록, 오늘날은 디지털화
`}
				</pre>

				<h3>[Centralized Ledger 중앙집중형]</h3>
				<pre>
					{`  - 중앙 집중형 원장 데이터의 신뢰는 중앙 기관의 신뢰성과 권위를 기반으루 형성 (은행, 회사, 정부 등)
  - 처리 속도가 빠를 수 있음

  - 중앙 서버가 해킹, 손상, 장애를 겪으면 데이터으 유실이나 손상 위험이 있음
  - 독점적으로 관리되므로 참여자는 데이터를 직접 검증하거나 확인할 수 없음

  *** 사토시 나카모토는 중앙화된 신뢰, 단일 장애점, 투명성을 해결하고 싶어했음
`}
				</pre>

				<h3>[Distributed Ledger 분산 원장]</h3>
				<pre>
					{`Q. What is Distributed Ledger?
A. 중앙 서버가 아닌 네트워크의 여러 노드 (참여자)에 걸쳐 분산 저장하는 데이터베이스의 일종
   데이터는 동기화되고 복제되서 모든 노드에 공유
   중앙기관이 없어 데이터의 무결성과 보안 유지 가능

Q. DL의 특징으로는?
A. 중앙 서버가 필요없다는 분산성, 데이터 기록후 변경 또는 삭제가 불가하기에 데이터의 무결성,
   모든 참여자가 동일한 데이터를 볼 수 있다는 신뢰성, 중앙 권한 없이 합의를 통해 데이터 추가/수정이 가능하다는 탈중앙화.

Q. 어떤 종류의 분산원장이 있는지?
A. 비트코인/이더리움과 같은 퍼블릭 블록체인/분산원장
   기업 내부에서 사용되어 제한된 참여자만 접근 가능한 프라이빗 분산원장 (예: 하이퍼레저)
   특정 그룹/기업 연합 등에서 공유되며 참여 노드가 제한되는 컨소시엄 분산원장
`}
				</pre>

				<h3>[DLT, Distributed Ledger Technology]</h3>
				<pre>
					{`Q. What is Distributed Ledger Technology (DLT)?
A. DLT is a decentralized database system where transactions are stored across multiple nodes instead of a single centralized server. This ensures transparency, security, and immutability.

  - 합의 알고리즘 : 모든 노드가 데이터의 유효성과 순서를 검증하고 동일한 기록을 유지하기 위해 사용하는 방식 (PoW PoS PBFT 등)
  - 암호화 : 기밀성, 무결성, 사용자 신원을 인증하기 위해 사용, 위변조와 부인을 방지할 수 있음
  - 노드 동기화 : 모든 노드가 동일한 데이터를 유지하도록 하며 데이터의 일관성과 무결성을 보장

[DLT 작동 방식]

  - 트랜잭션 생성 -> 모든 노드에 전파 -> 합의 알고리즘을 통해 유효성 검증 -> 데이터 저장 (동일한 데이터 사본을 모든 노드가 저장)

Q. DLT와 블록체인의 차이?
A. DLT는 데이터를 분산 저장하고 관리하는 모든 기술, 블록체인은 DLT의 한 구현 방식.
`}
				</pre>
			</div>
		),
	},
	{
		id: 7,
		date: '06/02/2025 (2) ',
		tags: ['Node', 'PoW', 'PoS', 'SPV', 'Blockchain'],
		title: 'NODE',
		content: (
			<div>
				<h3>Q. What is a Node in Blockchain?</h3>
				<pre>
					{`A. A node in blockchain is a computer that participates in the blockchain network by maintaining a copy of the distributed ledger and validating transactions
`}
				</pre>

				<h3>노드의 역할</h3>
				<pre>
					{`- 데이터 저장, 데이터 검증, 네트워크 연결 및 데이터 전파, 합의 참여(PoW, PoS)
`}
				</pre>

				<h3>노드의 유형</h3>
				<pre>
					{`- 풀 노드 : 블록체인의 모든 데이터를 저장하고, 트랜잭션과 블록의 유효성을 독립적으로 검증하는 노드
	e.g. 비트코인 코어 노드. 
- 라이트 노드 / SPV 노드 : 필요한 최소의 데이터만 저장하여 작동. 80바이트 크기의 블록 헤더만 다운로드
	e.g. 모바일 지갑
- 마이닝 노드 : PoW 수행하여 새로운 블록을 생성하는 노드, 합의 알고리즘에 참여하여 블록 보상을 얻음
- 검증 노드 (Validator Node) : PoS 네트워크에서 블록 생성 및 검증, 이더, 폴카닷, 솔라나에서 사용
- 아카이브 노드 : 블록체인의 모든 기록/상태를 저장하는 노드, 과거 기록 조회나 체인 전체 상태 분석에 사용
`}
				</pre>
			</div>
		),
	},
	{
		id: 8,
		date: '06/02/2025 (3) ',
		tags: ['BFT', 'Byzantine Fault Tolerance', 'Blockchain'],
		title: 'Byzantine Fault Tolerance',
		content: (
			<div>
				<h3>비잔틴 장애 허용(BFT)</h3>
				<pre>
					{`네트워크 내 일부 노드가 악의적이거나 오류를 발생시켜도,
나머지 정직한 노드가 올바른 합의에 도달하여 시스템이 정상적으로 작동하도록 보장하는 메커니즘
`}
				</pre>
			</div>
		),
	},
	{
		id: 9,
		date: '06/02/2025 (4) ',
		tags: ['PoW', 'Proof of Work', 'Blockchain'],
		title: 'Proof of Work',
		content: (
			<div>
				<h3>Proof of Work</h3>
				<pre>
					{`네트워크 참여자(마이너)는 먼저 퍼즐을 푸는 사람이 보상을 받는 경쟁적 구조
`}
				</pre>

				<h3>Fork</h3>
				<pre>
					{`- 이유?
    * 두 명 이상의 채굴자가 동시에 블록을 생성하여 네트워크에 전파했을 경우
    * 네트워크 지연으로 일부 노드가 특정 블록을 먼저 수신하고, 다른 블록을 뒤늦게 수신했을 경우

- 분기 상태
    * 두 체인의 길이가 동일하며, 각각 다른 노드 그룹에서 다른 체인을 유효한 체인으로 인식
    * 이 상황에서 블록체인은 일시적으로 "체인 분기(Fork)" 상태가 됩니다

=> 네트워크는 가장 긴 체인을 신뢰하며, 새 블록이 추가됨에 따라 다음 블록을 채굴하기 위한 작업반복
`}
				</pre>

				<h3>체인 리오르그(Chain Reorganization)</h3>
				<pre>
					{`- 기존 체인이 분기 체인 중 가장 긴 체인에 새롭게 이어지는 과정을 체인 리오르그
- 가장 긴 체인(가장 많은 작업량을 포함한 체인)이 더 많은 작업 증명을 했다고 합의(PoW) 했기 때문
`}
				</pre>

				<h3>Orphan Block</h3>
				<pre>
					{`- 네트워크가 새로운 체인을 메인 체인으로 선택하면, 기존의 짧은 체인의 블록들은 무효화됨
- 버려진 블록은 고아 블록(Orphan Block)으로 간주
- 이 고아 블록들은 다시 멤풀(메모리 풀)로 반환되어 다른 블록에 포함될 기회를 얻게 됨
`}
				</pre>

				<h3>PoW의 Pros</h3>
				<pre>
					{`- 높은 보안성 : 전체 해시 파워의 51% 이상을 장악해야 네트워크 공격이 가능하고, 높은 비용이 요구되어 현실적으로 불가능
- 검증 용이성 : 블록 헤더의 해시 값을 계산하여 블록이 타켓값 조건을 만족하는지만 확인하면 됨
`}
				</pre>

				<h3>PoW의 Cons</h3>
				<pre>
					{`- 채굴 과정에서 대량의 전력 소모
- 확장성 문제 : 트랜잭션 처리 속도가 제한적, 비트코인의 경우 초당 약 7건의 트랜잭션 처리
- 진입 장벽이 높음 : 일반 사용자의 참여가 어려움, 소수의 대교모 채굴 풀로 집중 됨
- 중앙화 위험 : 고성능 하드웨어와 막대한 전력비용을 요구하므로 채굴장비 제조사가 네트워크를 중앙화할 가능성이 있음
`}
				</pre>

				<h3>PoW 과반수 장악 위험성</h3>
				<pre>
					{`- 블록 생성 및 모든 보상 독점가능
- 이전의 트랜잭션을 취소하고 새로운 체인을 생성하며 코인을 다시 사용하는 이중 지불의 위험성이 있음
- 다른 채굴자들은 방해
`}
				</pre>
			</div>
		),
	},
	{
		id: 10,
		date: '06/02/2025 (5) ',
		tags: ['PoS', 'Proof of Stake', 'Blockchain'],
		title: 'Proof of Stake',
		content: (
			<div>
				<h3>Nothing at Stake</h3>
				<pre>
					{`한 체인에만 서명해야 한다는 제한이 없을 경우,
Validator가 자신의 보상을 극대화하기 위해 여러 체인에 동시에 서명하여 신뢰성을 저하시킬 수 있음
`}
				</pre>

				<h3>해결 방안</h3>
				<pre>
					{`- Slashing : 해당 발리데이터의 스테이킹 된 자산의 일부 또는 전부를 몰수 e.g.이더리움 슬래싱 규칙
- Longest Chain Rule : PoW처럼 "가장 긴 체인(또는 가장 많은 작업 증명을 포함한 체인)"만 유효한 체인으로 간주
- 보상 : 발리데이터가 한 체인에만 서명하도록 보상을 설계, 여러 체인에 할 경우 보상이 줄어들거나 손실
- 검증자 서명을 투명하게 공개하여 네트워크가 더블 스펜딩을 감지할 수 있도록 설계
`}
				</pre>

				<h3>Validator 선택 기준</h3>
				<pre>
					{`- 스테이킹된 코인의 양, 스테이킹한 기간을 베이스로 무작위 알고리즘을 통해 블록 생성자를 선택
- 스테이킹 양과 기간에 따른 확률이 높아짐
`}
				</pre>

				<h3>PoS의 Pros</h3>
				<pre>
					{`- 고전력 연산이 필요하지 않음
- 블록 생성 속도가 빠름
- 경제적 패널티를 통해 보안 강화
`}
				</pre>

				<h3>PoS의 Cons</h3>
				<pre>
					{`- 초기 지분이 많은 참여자가 유리함
- PoW보다 구현 및 운영이 복잡함
`}
				</pre>

				<h3>51% 공격 방지</h3>
				<pre>
					{`- PoS에서는 과반수의 지분을 확보해야 하므로, 전체 유통량의 절반 이상을 구매한다는 것은 경제적으로 어려움
- 네트워크를 손상시킬 경우, 스테이킹된 자산의 가치도 급락하므로 구지 공격 동기를 가지지 않음
`}
				</pre>
			</div>
		),
	},
	{
		id: 11,
		date: '06/02/2025 (6) ',
		tags: ['DPoS', 'Delegated Proof of Stake', 'Blockchain'],
		title: 'Delegated Proof of Stake',
		content: (
			<div>
				<h3>DPoS, 위임 지분 증명</h3>
				<pre>
					{`- Pos의 변형된 합의 알고리즘으로 높은 효율성과 확장성을 제공
- 대표자(Delegate)를 선출하여 블록 생성과 검증을 맡기고, 사용자가 이 대표자를 신뢰할 수 있도록 투표와 위임 메커니즘을 활용
- PoS의 효율성을 개선하면서도 PoW의 탈중앙화를 유지하려는 목표
`}
				</pre>

				<h3>DPoS 작동 방식</h3>
				<pre>
					{`- 상위 N명의 대표자만 블록 생성과 검증 권한을 얻음 e.g.EOS의 경우 21명의 대표자를 선출
- 복잡한 해시 계산이 필요하지 않으므로, 블록 생성 속도가 매우 빠름
- 대표자는 블록 생성 보상을 받고 자신에게 투표한 사용자와 보상을 공유

e.g. EOS, Tron, Steem
`}
				</pre>

				<h3>DPoS의 Pros</h3>
				<pre>
					{`- 초당 수천 건의 트랜잭션 처리 가능
- 민주적 구조, 네트워크 운영에 간접적으로 참여 가능
`}
				</pre>

				<h3>DPoS의 Cons</h3>
				<pre>
					{`- 소수의 대표자가 지배할 가능성, 담합 시 보안 위협 발생
- 투표 참여자가 적을 경우 대표가 전출이 왜곡될 가능성
`}
				</pre>
			</div>
		),
	},
	{
		id: 12,
		date: '06/02/2025 (7) ',
		tags: ['Mining', 'Bitcoin', 'Halving', 'Blockchain'],
		title: 'Mining',
		content: (
			<div>
				<h3>Miner</h3>
				<pre>
					{`통상적으로 PoW 합의 알고리즘에서 블록 생성 및 보상을 수행하는 노드를 채굴자(miner)라고 하고, PoS방식 등 전력 소모를 통해 블록을 생성하지 않는 다른 합의 알고리즘에서는 블록 제안자(proposer)라고 함
`}
				</pre>

				<h3>Halving</h3>
				<pre>
					{`- 반감기(Halving)는 블록체인 네트워크(특히 비트코인)에서 채굴 보상이 절반으로 줄어드는 주기적 이벤트를 의미
- 암호화폐의 공급량을 조절하고 희소성을 유지하며 궁극적으로 암호화폐의 가치를 보호하기 위한 메커니즘

    2009년: 블록당 보상 = 50 BTC
    2012년: 1차 반감기 → 25 BTC
    2016년: 2차 반감기 → 12.5 BTC
    2020년: 3차 반감기 → 6.25 BTC
    2024년: 4차 반감기 → 3.125 BTC
`}
				</pre>
			</div>
		),
	},
	{
		id: 13,
		date: '07/02/2025 (1) ',
		tags: ['Turing Completeness', 'Turing Machine', 'Blockchain'],
		title: 'Turing Completeness',
		content: (
			<div>
				<h3>Turing machine</h3>
				<pre>
					{`- 앨런 튜닝이 제안한 가상의 계산 모델로 현대 컴퓨터의 계산 가능성을 설명하는 기초가 되는 개념
- 구성요소 : 무한한 길이의 테이프(데이터 저장소), 읽기/쓰기 헤드, 상태머신
- 이론상으로는 모든 계산 가능한 문제를 모델링 할 수 있는 컴퓨터
`}
				</pre>

				<h3>Turing Completeness</h3>
				<pre>
					{`- 튜링 기계와 같은 계산 능력을 가졌음을 의미
- 어떠한 계산 가능 문제도 적절한 알고리즘과 충분한 시간과 메모리가 주어진다면 해결할 수 있다

- 조건?
	* Conditional branching : if-else같은 조건문을 처리할 수 있어야 함
		프로그램이 특정 조건에 따라 서로 다른 경로를 실행할 수 있어야 함
	* Arbitrary loops : while, for 루프와 같이 반복 실행이 가능해야 함
		프로그램이 특정 작업을 무한정 반복하거나 종료 조건이 충족될 때까지 반복할 수 있어야 함
`}
				</pre>

				<h3>튜링 완전한 시스템의 예</h3>
				<pre>
					{`- Phtyon, Java, C++, JS 등 대부분의 일반 프로그래밍 언너
- 스마트 계약 플랫폼 (이더리움) - Solidity는 튜링 완정성을 가짐, 계약 내에서 복잡한 계산과 조건 논리를 수행할 수 있음
`}
				</pre>

				<h3>튜링 불완전한 시스템의 예</h3>
				<pre>
					{`- 불완전한 시스템 : SQL, 비트코인 스크립트
`}
				</pre>
			</div>
		),
	},
	{
		id: 14,
		date: '07/02/2025 (2) ',
		tags: ['Ethereum', 'EVM', 'Smart contract', 'Blockchain'],
		title: 'Ethereum',
		content: (
			<div>
				<h3>Q. 이더리움의 핵심목표 ?</h3>
				<pre>
					{`A. 탈중앙화 어플리케이션을 지원하는 프로그래밍 가능한 블록체인을 만드는 것
`}
				</pre>

				<h3>비탈릭이 느낀 비트코인의 한계</h3>
				<pre>
					{`* 디지털 화폐로써만 사용되는 기술
* 비트코인의 스크립트 언어는 기능이 제한적
* 복잡한 스마트 계약이나 어플리케이션을 실행하기에는 부족

- 이더리움은 단순히 거래 데이터를 기록하는데 그치지 않고 스마트계약 기능을 통해 다양한 프로그램 실행기능을 제공
`}
				</pre>

				<h3>Smart contract</h3>
				<pre>
					{`- 스마트 계약은 블록체인 상에서 실행되는 자율적인 프로그램으로, 특정 조건 충족 시 자동 실행
- 솔리디티와 같은 프로그래밍 언어로 작성되며, 특정 규칙을 코딩하고 이를 블록체인에 배포 또는 실행할 수 있음
`}
				</pre>

				<h3>EVM</h3>
				<pre>
					{`- 개발자는 EVM에서 실행 될 코드를 작성해여 배포할 수 있으며, 코드는 모든 이더리움 네트워크 노드에서 동작
`}
				</pre>
			</div>
		),
	},
	{
		id: 15,
		date: '07/02/2025 (3) ',
		tags: ['Ethereum', 'Bitcoin', 'EVM', 'Smart contract', 'Virtual machin', 'Blockchain'],
		title: 'Ethereum VS Bitcoin',
		content: (
			<div>
				<h3>비트코인</h3>
				<pre>
					{`목적 : 디지털 통화(가치 저장 및 거래)
네트워크 설계 : 단순하고 안정적인 설계
곡선 알고리즘 : ECDSA (secp256k1)
해시 함수 : SHA-256 + RIPEMD-160 
주소 표현 : Base58 인코딩, 숫자와 문자 조합
`}
				</pre>

				<h3>이더리움</h3>
				<pre>
					{`목적 : 스마트 계약 및 탈중앙화 애플리케이션 실행
네트워크 설계 : 유연하고 확장 가능한 설계
곡선 알고리즘 : ECDSA (secp256k1)
해시 함수 : Keccak-256
주소 표현 : 16진수(40자), "0x"로 시작 
`}
				</pre>

				<h3>이더리움 - 어카운트 기반 모델</h3>
				<pre>
					{`- EOA (Externally Owned Account) 외부 소유 계정 : 비공개 키에 의해 제어, 트랜잭션을 생성
- Contract Account : 특정 코드가 배포된 계정, 트랜잭션이 발생하면 해당 코드 실행

- Nonce in Ethereum : 해당 계정에서 보낸 트랜잭션의 횟수, 계정별 트랜잭션의 고유 식별자
	재사용/복사 방지, 여러 트랜잭션이 동시발생할 경우 순서를 결정하는데 사용
`}
				</pre>

				<h3>Virtual Machine</h3>
				<pre>
					{`- 우리가 작성한 코드와 컴퓨터(하드웨어) 사이에 추상화 계층을 생성하는 역할
- 소프트웨어의 이식성을 향상시키고, 프로그램들이 서로 격리된 상태에서 독립적으로 실행할 수 있도록 해줌
`}
				</pre>

				<h3>EVM</h3>
				<pre>
					{`- 	Solidity 코드를 solc를 통해 컴파일 
	-> EVM이 이해할 수 있는 바이트코드로 변환 
	-> 이더리움 네트워크로 배포
`}
				</pre>

				<h3>바이트코드</h3>
				<pre>
					{`- EVM에서이 바이트코드는 스택 기반 아키텍처 (프링글스)
- 명령어는 Opcode로 해석 
`}
				</pre>

				<h3>Smart contract Pros</h3>
				<pre>
					{`- 보안 : 누군가에게 뇌물을 주거나 계약 내용이나 결과를 변조할 위험성이 없음
- 신뢰성 : 로직 조건에 부합해 계약이 이행되면, 네트워크의 노드들에 의해 여러 번 수행/검증되기 때문에 위변조가 어려움
- 공평함 : 분산화된 블록체인을 사용하기 때문에 수수료를 가지거나 특정 목적의 제3자가 필요하지 않음
- 효율성 : 계약 당사자들이 수동으로 데이터를 입력하거나, 상대의 계약 의무 이행 여부를 검증 등을 확인할 필요가 없음
`}
				</pre>

				<h3>Smart contract Cons</h3>
				<pre>
					{`- 컨트랙트 배포 이후에 작동 수정이 불가능함
- 프록시 패턴(업그레이더블)과 같은 컨트랙트 업그레이드 방법이 있지만 완벽한 해결책은 아님
- 날씨나 환율과 같은 외부 데이터를 활용해야 하는 경우에 오라클을 사용하지만,
	이 제공된 데이터를 신뢰할 수 있는지 전달 과정에서 오류가 발생하지 않는지 확인해야 함.
	악의적인 데이터 입력 시 계약이 의도하지 않은 방식으로 실행될 위험도 존재 
`}
				</pre>
			</div>
		),
	},
	{
		id: 16,
		date: '11/03/2025',
		tags: ['eSports', 'Sports', 'PoSA', 'Chiliz', 'Blockchain'],
		title: 'Chiliz Chain 🌶️',
		content: (
			<div>
				<h3>A blockchain designed for fan engagement in sports and entertainments</h3>
				<pre>
					{`- 전 세계 수십억 명의 스포츠 & e스포츠 팬들에게 하나의 통화를 제공하여, 좋아하는 팀과 조직에 대한 직접적인 투표 권한을 부여
- 팀, 리그, 이벤트 및 게임을 위한 크라우드 매니지먼트 플랫폼 구축 (다양한 산업에 적용 가능)

- eSports + Video games 마켓사이즈 > Film + Music 
- 그 중에서도 Sport 시장은 최대의 글로벌 엔터테인먼트 산업
`}
				</pre>

				<h3>제한점 (Limitations)</h3>
				<pre>
					{`- 일반적인 거래용 코인이 아니라, 스포츠 및 엔터테인먼트 특화된 블록체인
- 스포츠 & 엔터테인먼트 생태계에서는 충분히 적합한 구조지만, 완전한 탈중앙화 블록체인을 원하는 경우 한계가 있을 수 있음
`}
				</pre>

				<h3>커뮤니티 (Community)</h3>
				<pre>
					{`⚽ FC 바르셀로나, 유벤투스, PSG, UFC 등 세계적인 스포츠 팀 및 리그와 파트너쉽
https://www.socios.com/teams/

- 사용 사례 (Use Case) :
	Fan Token을 구매하서, 구단 의사 결정 투표 참여 / 리워드 및 VIP 경험 제공
	Fun fact! 유니폼 디자인, 경기 전 음악, 친선 경기 상대팀 등을 결정하는 투표에도 참여
`}
				</pre>

				<h3>합법성 및 신뢰성 (Legitimacy)</h3>
				<pre>
					{`- 유럽 연합(EU) 내 몰타(Malta)에서 개발
- 몰타 정부의 지원을 받아 실행 ... 🤨🤨🤨???
- EEA (Enterprise Ethereum Alliance) 회원사
`}
				</pre>

				<h3>Socios</h3>
				<pre>
					{`Chiliz (칠리즈)
	- 블록체인 플랫폼 & 네이티브 토큰(CHZ)
	- 스포츠 & 엔터테인먼트 분야의 팬 토큰을 위한 블록체인 인프라
	- 자체 블록체인인 Chiliz Chain을 기반으로 운영
	- CHZ 토큰은 팬 토큰 구매, 거래, 보상 시스템에서 활용

Socios (소시오스)
	- 팬들이 실제로 이용하는 서비스 (플랫폼 & 앱)
	- Chiliz 블록체인을 사용하여 팬 토큰 발행, 투표, 리워드 제공
	- 웹사이트 & 모바일 앱에서 팬들이 CHZ를 사용해 팬 토큰을 구매하고, 구단 의사 결정 투표 가능
	- 유명 클럽(FC 바르셀로나, 유벤투스, PSG 등)이 Socios 플랫폼을 활용
`}
				</pre>

				<h3>Chiliz Chain 주요 특징</h3>
				<pre>
					{`EVM 호환성
	- Chiliz Chain은 BSC포크이며, BSC 자체가 이더리움 포크
	- 따라서 Ethereum 툴링과 호환되어 개발자가 쉽게 구축 가능

지분 권한 합의 증명 (PoSA, Proof of Staked Authority)
	- PoA(Proof-of-Authority)와 PoS(Proof of Stake)를 결합한 하이브리드 합의 알고리즘
	- 더 빠른 블록 생성 및 낮은 거래 비용 제공
	- 제한된 수의 검증자가 블록을 생성하며, 검증자 세트는 스테이킹 거버넌스를 통해 선출

검증자 수 제한
	- 11개의 검증자 시스템 도입
	- 가장 많은 스테이킹을 한 검증자 후보가 검증자로 선정되어 블록 생성

네이티브 토큰: CHZ
	- Chiliz Chain의 기본 토큰
	- 스마트 계약을 배포/호출할 때 가스 비용 지불
	- Chiliz Chain과 Ethereum 간 크로스체인 브리징이 가능
	- 스테이킹 및 위임을 통해 네트워크 보안 유지
`}
				</pre>

				<h3>Pros 👍🏽</h3>
				<pre>
					{`1.	EVM 호환성
	- Ethereum과 호환되므로 기존 Solidity 기반 DApp을 쉽게 Chiliz Chain으로 포팅 가능
	- MetaMask, Hardhat, Remix, Web3.js, Viem, Wagmi 같은 Ethereum 개발 툴 사용 가능
2.	빠른 트랜잭션 속도 & 낮은 수수료
	- PoSA(Proof of Staked Authority) 합의 메커니즘을 사용해 빠른 블록 생성
	- 이더리움 대비 낮은 가스 비용
3.	스포츠 & 엔터테인먼트 특화 블록체인
	- FC 바르셀로나, 유벤투스, PSG, UFC 같은 유명 스포츠 팀과 제휴
	- 팬 토큰 발행 및 커뮤니티 참여 기능 내장
4.	PoSA 합의 알고리즘을 통한 보안 & 네트워크 안정성
	- 검증자(Validator) 선출 및 스테이킹 기반 거버넌스로 신뢰성 유지
	- 네트워크 공격 가능성이 낮음
5.	Tokenomics 2.0으로 인한 장기적 지속 가능성
	- 점진적으로 감소하는 인플레이션 모델로 공급량 조절
	- EIP-1559 모델 도입으로 가스 수수료 일부 소각 → 장기적 디플레이션 가능성
`}
				</pre>

				<h3>Cons 👎🏽</h3>
				<pre>
					{`1.	검증자 수 제한 → 중앙화 논란
	- 검증자가 11개로 제한되어 있음 (Ethereum처럼 누구나 검증자가 될 수 있는 구조가 아님)
	- PoSA 구조로 인해 일부 검증자가 네트워크를 과도하게 통제할 가능성 존재
2.	PoSA의 낮은 분산성
	- PoS(Poof of Stake)보다 검증자가 적고, 네트워크 참여자가 검증자 세트에 쉽게 들어가기 어려움
	- 진정한 탈중앙화라고 보기 어려운 구조
3.	스포츠 & 엔터테인먼트에 특화된 점이 장기적 확장성에 제약이 될 수 있음
	- DeFi, NFT, 게임, DAO 같은 다른 Web3 생태계와의 통합이 Ethereum, Solana, Avalanche에 비해 제한적
`}
				</pre>

				<h3>Conclusion</h3>
				<pre>{`- 탈중앙화는 거의 불가능한 구조
	•	검증자(Validator) 수가 11개로 제한 → 완전한 탈중앙화는 사실상 불가능
	•	PoSA(Proof of Staked Authority) 구조 자체가 기업/기관 중심 운영을 위한 합의 알고리즘
	•	네트워크의 주요 결정권은 결국 소수의 검증자가 가진다 → 실질적으로 중앙화된 시스템
	•	일반적인 블록체인 커뮤니티처럼 탈중앙화 거버넌스를 실현하기 어려움

- 투명성과 신뢰성 측면에서는 다소 의문
	•	몰타에서 설립 및 운영 → 규제적인 안전성은 있지만, 투명성 측면에서는 물음표
	•	대형 스포츠 팀, 기업과의 파트너십이 많아 오픈소스 개발자 중심의 탈중앙화 네트워크보다는 기업 중심 운영이 될 가능성 큼
	•	스포츠 클럽, 브랜드, 투자자 중심의 의사 결정이 많을 것 → 일반 유저들이 직접 영향력을 행사하기 어려울 가능성 큼
	•	PoA 기반 시스템 특성상, 네트워크 검증자에 대한 신뢰가 필요 → 완전한 온체인 거버넌스 불가능

- 사업성 측면에서 매우 유망한 블록체인
	•	스포츠 팬덤 시장은 전 세계에서 가장 크고 충성도가 높은 시장 중 하나
	•	이미 FC 바르셀로나, 유벤투스, PSG, UFC 같은 글로벌 브랜드와 제휴 → 시장 장악력 강함
	•	팬덤 기반 경제 모델이므로 망할 가능성이 낮음 (스포츠 팬덤이 존재하는 한, 지속될 가능성이 높음)
	•	기존 Web3 기업보다 Web2 기업(스포츠 클럽, 브랜드)에게 더 매력적인 블록체인
	•	기업과 스포츠 팀 중심의 거버넌스 모델이라 장기적으로도 안정성이 높을 것

- 투자 및 경제 모델 측면에서 강력함
	•	CHZ는 이미 스포츠 팬덤 기반으로 실사용 사례가 많음
	•	기존 Tokenomics에서 벗어나, EIP-1559 기반의 소각 모델 + 점진적인 인플레이션 감소 적용 → 장기적으로 토큰 가치 방어 가능성 높음
	•	팬덤 기반 경제 모델이라 단순 투기보다는 실제 사용성이 높은 블록체인

- 결론: 팬덤이 강한 만큼 강한 블록체인, 하지만 완전한 탈중앙화 블록체인은 아님
	•	Web3보다는 Web2 스포츠 기업에 더 적합한 블록체인
	•	중앙화된 운영 모델을 기반으로, 장기적으로는 강력한 비즈니스 모델
	•	탈중앙화 이념과 거리가 멀지만, 사업적으로는 확실히 성공 가능성이 높음
	•	완전한 투명성을 기대하기는 어렵고, 내부 정책이 중요한 블록체인
	•	지속적인 성장 가능성은 높지만, 구조적으로 “깨끗한” 블록체인은 아닐 가능성이 큼

한 줄 정리 : 🔹 사업성 굿 ✅ | 탈중앙화 ❌ | 망할 일 없음 🚀 | 투명 X 🤨
				`}</pre>
			</div>
		),
	},
	{
		id: 17,
		date: '11/03/2025',
		tags: ['PoSA', 'PoA', 'Chiliz', 'Blockchain'],
		title: 'PoSA vs PoS vs PoA',
		content: (
			<div>
				<h3>PoA (Proof of Authority) - 권한 증명 합의 알고리즘</h3>
				<pre>
					{`🔹 PoA (Proof of Authority) - 권한 증명 합의 알고리즘
	•	신뢰할 수 있는 검증자(Validator) 몇 명을 사전에 선정하여 블록을 생성
	•	주로 기업형 블록체인 또는 프라이빗 블록체인에서 사용 (예: VeChain)

✅ PoA 특징
	1.	초고속 트랜잭션 (소수의 검증자만 있기 때문에 합의 속도가 매우 빠름)
	2.	가스 비용 거의 없음
	3.	기업, 기관에서 사용하기 적합

❌ PoA 단점
	•	극단적인 중앙화 구조 (소수의 검증자가 네트워크 통제)
	•	검증자를 신뢰해야 하는 구조 (탈중앙화 정신과 맞지 않음)
	•	오픈 네트워크에서 사용하기 어려움
`}
				</pre>

				<h3>PoSA (Proof of Staked Authority) - 지분 권한 합의 증명</h3>
				<pre>
					{`🔹 PoSA (Proof of Staked Authority) - 지분 권한 합의 증명
	•	PoA(Proof of Authority) + PoS(Proof of Stake) 를 결합한 하이브리드 합의 알고리즘
	•	BNB Smart Chain(BSC)에서 사용되며, Chiliz Chain도 이를 포크해서 활용

✅ PoSA 특징
	1.	검증자(Validator) 수 제한 → 11명의 검증자가 선출됨
	2.	검증자는 PoA 방식으로 블록을 생성
	3.	PoS 기반 스테이킹 거버넌스로 검증자 선출
	4.	빠른 블록 생성 & 낮은 트랜잭션 비용
	5.	검증자 세트가 중앙화될 가능성 존재
`}
				</pre>

				<h3>PoS</h3>
				<pre>
					{`🔹 PoS (Proof of Stake) - 지분 증명 합의 알고리즘
	•	이더리움, 솔라나, 폴리곤, 아발란체 같은 주요 블록체인에서 사용
	•	채굴(마이닝) 없이 토큰을 스테이킹한 참여자가 검증자(Validator)가 되어 블록을 생성
	•	검증자는 많은 스테이킹을 한 순서대로 블록 생성 권한을 얻음

✅ PoS 특징
	1.	에너지 효율적 (채굴 필요 없음)
	2.	스테이킹을 통해 누구나 검증자로 참여 가능 (네트워크 탈중앙화)
	3.	보유한 토큰이 많을수록 검증자로 선출될 가능성 증가
	4.	네트워크 공격 가능성 낮음 (51% 공격이 어려움)

❌ PoS 단점
	•	자본력에 따라 검증자 독점 가능성 (부자가 더 많은 블록을 생성할 가능성 높음)
	•	Slashing(처벌 메커니즘) 필요 (검증자가 악의적인 행동을 할 경우 스테이킹 토큰을 삭감)
`}
				</pre>
			</div>
		),
	},
	{
		id: 18,
		date: '12/03/2025',
		tags: ['On-chain', 'Blockchain'],
		title: 'On-chain data',
		content: (
			<div>
				<h3>트랜잭션 데이터(Transaction Data)</h3>
				<pre>
					{`- 트랜잭션 ID (Transaction Hash): 트랜잭션을 식별하는 고유한 해시 값
- 보낸 주소 (From Address): 트랜잭션을 보낸 계정 주소
- 받는 주소 (To Address): 트랜잭션을 받는 계정 주소 또는 스마트 컨트랙트 주소
- 전송된 금액 (Value): 트랜잭션에서 이동한 암호화폐 또는 토큰의 양
- 가스 사용량 (Gas Used): 트랜잭션을 처리하는 데 사용된 가스 양
`}
				</pre>

				<h3>블록 데이터(Block Data)</h3>
				<pre>
					{`- 블록 해시 (Block Hash): 특정 블록을 식별하는 고유한 해시 값
- 블록 번호 (Block Number): 해당 블록의 높이(높은 숫자일수록 최신 블록)
- 블록 생성 시간 (Timestamp): 블록이 생성된 시간
- 채굴자 주소 (Miner Address): 블록을 생성한 채굴자의 주소
- 트랜잭션 목록 (Transactions): 블록에 포함된 모든 트랜잭션
`}
				</pre>

				<h3>상태 데이터(State Data)</h3>
				<pre>
					{`- 계정 잔액 (Account Balance): 특정 계정의 보유 암호화폐 양.
- 스마트 컨트랙트 저장소 (Contract Storage): 스마트 컨트랙트가 저장하는 데이터.
- 토큰 보유량 (Token Balance): ERC-20 같은 토큰을 보유한 계정의 잔액 정보.
`}
				</pre>

				<h3>온체인 데이터를 조회하는 방법</h3>
				<pre>
					{`- 직접 노드 운영 → Geth, Erigon, Besu 등 실행.
- RPC 인프라 제업체 이용 → Infura, Alchemy, QuickNode 등 사용.
- Web3 SDK 활용 → Web3.js, Ethers.js 등을 사용해 온체인 데이터 조회.
`}
				</pre>
			</div>
		),
	},
	{
		id: 19,
		date: '12/03/2025 (2)',
		tags: ['RPC', 'JSON', 'Node', 'Blockchain'],
		title: 'Node',
		content: (
			<div>
				<h3>Node</h3>
				<pre>
					{`- 블록체인은 블록과 트랜잭션 데이터를 확인할 수 있는 소프트웨어(노드)를 실행하는 컴퓨터의 분산 네트워크. 
- 노드를 "실행"하려면 컴퓨터에 "클라이언트"라고 하는 응용 프로그램이 필요합니다 eg. Bitcoin Core, Geth 등
`}
				</pre>

				<h3>JSON-RPC</h3>
				<pre>
					{`- RPC(Remote Procedure Call) : 
	* 별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 리모트의 함수나 프로시저를 실행 할 수 있게 해주는 프로세스간 통신
- JSON-RPC API : 
	* JSON-RPC는 무상태성(Stateless)의 경량 RPC(원격 프로시저 호출) 프로토콜
	* 소켓 통신이나 HTTP 등 다양한 메시지 전달 환경에서 사용할 수 있도록 추상화 되어 있음
	* JSON(RFC 4627)의 데이터 형식으로 사용
`}
				</pre>

				<h3>e.g. 터미널에서 RPC-call 해보기</h3>
				<SyntaxHighlighter language='solidity' style={vscDarkPlus}>
					{`curl -X POST https://public-en-kairos.node.kaia.io \
  -H "Content-Type: application/json" \
  --data '{
    "jsonrpc": "2.0",
    "method": "eth_getBalance",
    "params": ["0x7F4eCb81082eE10c330B926F64E34a9102de4F03", "latest"],
    "id": 1
  }'
`}
				</SyntaxHighlighter>
			</div>
		),
	},
	{
		id: 20,
		date: '12/03/2025 (3)',
		tags: ['Gwei', 'Wei', 'Ether', 'ETH', 'Blockchain'],
		title: 'Ether units',
		content: (
			<div>
				<h3>Units</h3>
				<pre>
					{`이 단위들은 이더리움 네트워크에서 트랜잭션 수수료(Gas Fee) 계산 및 정밀한 금액을 표현하는 데 필수적

1 ETH = 1,000,000,000 Gwei (10⁹ Gwei)
1 Gwei = 1,000,000,000 Wei (10⁹ Wei)
0.0001 ETH = 100,000 Gwei
`}
				</pre>

				<h3>3가지 주요 단위</h3>
				<pre>
					{`✅ Wei
이더리움의 가장 작은 단위.
스마트 컨트랙트와 트랜잭션에서 정밀한 계산이 필요할 때 사용됨
1 Wei = 0000000000000000001 ETH (10⁻¹⁸ ETH)

✅ Gwei (가스 가격 단위)
이더리움 트랜잭션 수수료(Gas Fee) 계산에서 주로 사용됨
대부분의 블록 탐색기나 지갑에서 **Gas Price(가스 가격)**는 Gwei 단위로 표시됨

예: 50 Gwei = 0.00000005 ETH

✅ Ether (ETH)
이더리움 네트워크의 기본 화폐 단위
일반적으로 ETH 단위로 잔액을 표시하며, 트랜잭션 송금에도 사용됨
`}
				</pre>

				<h3>이더리움 단위가 다양한 이유</h3>
				<pre>
					{`- 높은 정밀도 필요: Wei 같은 작은 단위를 사용하여 정확한 수수료 계산 및 미세한 거래 가능
- 가스비 최적화: Gwei 단위를 활용하면 가스 비용을 쉽게 조정할 수 있음
- 스마트 컨트랙트 개발 최적화: 스마트 컨트랙트는 Wei 단위를 사용하여 정확한 연산 수행 가능
`}
				</pre>
			</div>
		),
	},
	{
		id: 21,
		date: '12/03/2025 (4)',
		tags: ['API', 'Infura', 'Ganache', 'Blockchain'],
		title: 'Ganache',
		content: (
			<div>
				<h3>이더리움 노드</h3>
				<pre>
					{`이더리움 노드는 Geth나 Parity를 사용하여 실제 이더리움 메인(또는 테스트) 네트워크에 접속하여 블록을 모두 동기화시켜야 
그러나 블록을 동기화 시키는데만 해도 2-3일 정도 소요되며, 
트랜잭션을 보내도 블록을 생성하기까지 기다려야 하는 등 스마트 컨트랙트를 개발 할 때 불편한 점이 많습니다!

그래서 Ganache 같은 가상/프라이빗 네트워크 상에서 컨트랙트를 구동해 볼 수 있음
`}
				</pre>

				<h3>Ganache</h3>
				<pre>
					{`가나슈(Ganache)는 가상의 이더리움 네트워크를 생성해서 스마트 컨트랙트를 실행할 수 있도록 해주는 프로그램
가나슈 등을 이용해 만든 가상 환경이 TestRPC
`}
				</pre>

				<h3>e.g. API Call</h3>
				<SyntaxHighlighter language='solidity' style={vscDarkPlus}>
					{`curl -X POST https://polygon-amoy.infura.io/v3/{자신의 API Key} \
  -H "Content-Type: application/json" \
  --data '{
    "jsonrpc": "2.0",
    "method": "eth_getBalance",
    "params": ["{자신의 지갑 주소}", "latest"],
    "id": 1
  }'
`}
				</SyntaxHighlighter>
			</div>
		),
	},
	{
		id: 22,
		date: '12/03/2025 (5)',
		tags: ['Web3js', 'JSON RPC', 'P2P', 'Blockchain'],
		title: 'Web3.js',
		content: (
			<div>
				<pre>
					{`- Web3.js는 이더리움 블록체인과 JSON RPC(Remote Procedure Call)를 사용하여 소통
- 이더리움은 여러 노드로 구성된 P2P 네트워크이며 블록체인에 있는 모든 데이터와 코드의 사본을 저장하고 있음
- Web3.js는 네트워크에 있는 데이터를 읽거나 써야 할 때 JSON RPC를 사용해 하나의 이더리움 노드에게 요청을 보냄
	(이더리움에서는 클라이언트가 JSON RPC라는 정해진 형식에 맞춰서 이더리움 노드에 데이터를 요청)
`}
				</pre>

				<h3>Modules</h3>
				<pre>
					{`web3-eth: 이더리움 블록체인과 스마트 컨트랙트 모듈
web3-shh: P2P 커뮤니케이션과 브로드캐스트를 위한 위스퍼 프로토콜 모듈
web3-bzz: 탈중앙화 파일 스토리지를 위한 스왐 프로토콜 모듈
web3-utils: dApp 개발자를 위한 유용한 헬퍼 함수들을 모아둔 모듈
`}
				</pre>
			</div>
		),
	},
	{
		id: 23,
		date: '13/03/2025',
		tags: ['Maple story universe', 'MSU', 'MapleStory N', 'DApp', 'Blockchain'],
		title: 'Maple Story Universe',
		content: (
			<div>
				<h3>Nexon </h3>
				<pre>
					{`- 국내 최초로 온라인 RPG게임 <바람의 나라>를 출시
- 온라인 게임 수익 모델의 근간인 부분 유료화 (Free to Play)를 처음으로 도입
- 온라인 게임의 비즈니스 모델을 정립
- 국내 게임 업계가 폭발적으로 성장하는 계기가 됨
`}
				</pre>

				<h3>Maple Story</h3>
				<pre>
					{`2000년경 MMORPG가 처음 붐을 일으켰을 때, 
MMORPG는 진지하고 어렵고 복잡한 게임이라는 일반적인 믿음이 있었다고.

메이플스토리는 2003년 2D 횡스크롤 MMORPG로 처음 출시되어 약 20년 동안 사랑 받음
메이플스토리는 이런 고정관념에 도전했고, 귀여운 그래픽과 캐주얼한 게임플레이를 갖춘 MMORPG로 인기를 얻음
특히 젊은 게이머들에게 사랑받았고 MMORPG와 온라인 게임을 대중화하는 데 중요한 역할을 함!
					`}
				</pre>

				<h3>문제점?</h3>
				<pre>
					{`- 넥슨은 20년 동안 성장하는 장수 게임을 만들어 왔지만 => 유저들의 평균 연령 또한 높아짐
- 커뮤니티에 대한 뛰어난 이해도를 바탕으로 생태계를 성장시키는데 성공하였으나 
	앞으로도 지속 성장하기 위해서는 변화가 필요하다고 판단
- 게임사가 주도하는 컨텐츠 공급에는 한계가 있음을 인지
- 기존 부분유료화 모델에도 매출 성장을 만들어 내는데 제한이 있다고 판단
`}
				</pre>

				<h3>MapleStory Universe</h3>
				<pre>
					{`- 넥스페이스라는 자회사를 설립
- 메이플스토리라는 초대형 IP에 Web3 요소를 도입 
	(전통적인 게임사들이 Web3 모델을 도입하는 대표적인 사례 중 하나)

MapleStory Universe : Perfecting the core MMORPG Experience with blockchain

- MapleStory IP를 공유하는 다양한 게임과 앱이 MapleStory NFT를 통해 상호 작용할 수 있는 가상 세계
- MapleStory N, blockchain development sandbox platform mode N, MapleStory N SDK
`}
				</pre>

				<h3>IP(지식 재산, Intellectual Property)</h3>
				<pre>
					{`- IP란? 게임, 영화, 캐릭터, 소설, 음악 등 창작물이나 브랜드의 법적 권리를 의미
- 게임에서의 IP?
	게임 업계에서 IP란, 특정 게임이 가지고 있는 브랜드, 세계관, 캐릭터, 스토리 등을 뜻 함
	유명한 게임이나 캐릭터 자체가 IP가 됨

e.g.
	• 메이플스토리 IP → 메이플스토리 세계관, 캐릭터(슬라임, 핑크빈, 루시드 등), 스토리, 디자인, 음악 등
	• 포켓몬 IP → 포켓몬 캐릭터(피카츄, 리자몽), 게임, 애니메이션, 카드 게임 등
	• 디즈니 IP → 미키 마우스, 마블, 스타워즈 등

--------------------------------------------------

IP는 게임 산업에서 엄청 중요한 요소!

- 게임사가 새로운 게임을 만들 때, 기존 IP를 활용하면 팬층이 이미 있기 때문에 성공 확률이 높음
	=> 기존 메이플스토리 IP를 활용하여 블록체인 게임을 만들면, 기존 유저층을 확보하기 쉬움
- 기존 캐릭터, 몬스터, 아이템 등을 NFT로 온체인화하여 경제 모델을 만들 수 있음
- 메이플스토리는 한국 & 글로벌에서 강력한 충성도 높은 팬층을 보유하고 있음
`}
				</pre>

				<h3>목표?</h3>
				<pre>
					{`- ‘무한한 콘텐츠 공급’과 ‘신규 비즈니스 모델의 도입’.
- 크리에이터 역할을 하는 유저에게 인게임 생태계 창작에 대한 보상 으로 토큰 기반의 인센티브를 제공하여 콘텐츠 생성에 대한 유인을 높임
- 아이템거래소와 같이 넥슨이 구축한 유니버스 생태계 내 핵심 인프라 서비스들로부터 수수료를 수취(NFT 마켓플레이스의 수수료 모델)도 비즈니스 모델 중 하나
- 토큰과 아이템(NFT)의 거래가 블록체인을 통해 투명하게 공개됨에 따라 지금까지 논란이 되었던 확률 조작, 아이템 인플레이션과 같은 노이즈가 발생할 가능성이 낮고
- 투명하게 이뤄질 것으로 기대 / 유저로부터 게임 운영에 대한 신뢰를 쌓을 수 있도록 하려고 함
`}
				</pre>

				<h3>토크노믹스</h3>
				<pre>
					{`- 콘텐츠 창작 인센티브 제공
	* 창작자 인센티브는 NXPC 토크노믹스의 가장 중요한 요소 중 하나
	* 창작자들이 자신이 만든 콘텐츠로부터 실질적인 보상(NXPC 보상)을 받을 수 있도록 설계된 메이플스토리 유니버스 보상 시스템
	* 기존의 메이플스토리 크리에이터 수익 공유 모델과 달리 투명 & 신속

- 지속적인 콘텐츠 업그레이드
	* NXPC토큰은 단순한 보상의 수단을 넘어, 크리에이터들이 콘텐츠를 제작하는 데 필요한 자원 제공 역할도 함 
	* 크리에이터들은 NXPC를 사용해 주요 아이템 민팅, 이를 자신의 콘텐츠 내에서 활용할 수 있음
	* 창작자들은 NXPC 현금화 대신 아이템풀에서 컨텐츠 요소로 활용할 아이템에 재투자하여 콘텐츠를 확장
		=> "NXPC를 통해 콘텐츠 제작 아이템을 구매하는 구조는 NXPC의 강력한 수요처를 만들어 내는 한편,
	 	    MSU의 콘텐츠 생태계를 풍부하게 하여, 창작자와 유저들의 참여를 지속적으로 이끌어낼 것이다"

- 탈중앙화된 콘텐츠 플레이로 유저 몰입도 증가
	* NXPC 인센티브를 받는 크리에이터는 각자의 플래닛을 구축하여 콘텐츠를 생산하고 유저에게 제공
	* 초기에는 넥스페이스 주도의 메이플스토리N 게임을 출시하고 유저들에게 제공할 계획이며, 
	  점차 크리에이터 풀을 늘려가는 것이 플레이 로드맵
	* 유저 입장에서는 크리에이터들이 구축한 다양한 플래닛에서 플레이 가능
	* 기존의 RPG 게임의 고질적인 문제였던 고인물화를 어느 정도 해결할 수 있을 것으로 기대???

e.g. 메이플스토리N이라는 플래닛에서 획득한 특정 아이템은 다른 플래닛에서는 완전히 다른 효과를 가질 수 있고 
	 개별 플래닛의 크리에이터는 자신이 제작한 콘텐츠의 컨셉과 기획에 맞춰
	 각 아이템의 세부 능력치를 조절할 수 있음.
	 이러한 탈중앙적 개발 환경은 유저가 특정 생태계에 머무르지 않더라도, 
	 다양한 생태계에 참여하여 게임을 즐길 수 있는 동기를 부여할 수 있다. 

- 문제점 ? 
"토크노믹스가 접목된 게임의 경우 쌀먹으로 불리우는 작업장 유저들이 많아 게임 사이클이 빠르게 끝난다는 단점이 지적되어 왔다. 하지만 한편으로는 유저들이 실제 현금화가 가능한 NFT아이템과 토큰을 소유하는 만큼 재접속률과 같은 리텐션 지표가 상대적으로 높다는 주장도 제기되었다. 지난 7~8월 진행된 MSU Pioneer 테스트 결과 유저들의 몰입도가 기존 게임 대비 높아졌음을 확인할 수 있었다. 물론 아직 테스트 규모가 적은 만큼 Web3 요소가 접목된 게임이 실제로 유저의 게임 플레이 몰입을 증가시키는지는 추가 검증이 필요하나, 초기 테스트 결과로서는 의미가 있었다."

(이미지 설명)
						`}
				</pre>

				<h3>신조어 코어!? 쌀먹 🌾</h3>
				<pre>
					{`“쌀을 먹는다”의 줄임말로, 주로 게임, NFT, 코인 등의 커뮤니티에서 사용되는 신조어라고 합니다???

	• 돈을 벌 목적으로 게임을 하거나 특정 활동을 하는 것을 뜻함
	• 주로 P2E게임에서 “쌀먹러”라는 표현이 많이 사용되는데, 
	  게임을 즐기기보다 경제적 이득을 목적으로 플레이하는 유저를 가리킴
	• NFT, 코인 커뮤니티에서도 단기 이익을 얻기 위해 빠르게 사고파는 투자자를 의미할 때 쓰이기도 함
						`}
				</pre>

				<h3>토큰의 가치</h3>
				<pre>
					{`1. NFT 기반 아이템 & 경제 시스템
	• 게임 내 아이템과 자산이 NFT로 발행되어 온체인에서 보유/거래 가능
	• 기존 메이플스토리에서는 유저가 아이템을 가질 수 없었지만, Web3 버전에서는 소유권이 주어짐
	• 유저가 노력한 만큼 자산을 축적할 수 있음

2. 유저 주도 경제 (UGC, User-Generated Content) 시스템
	• 유저가 직접 콘텐츠를 제작 & 거래 가능
	• 예를 들어, 유저가 만든 스킨, 아바타, 아이템 등을 NFT로 판매할 수 있음

3. Play & Earn 모델 (P2W 방지)
	• 기존 Web3 게임들은 Play-to-Win 모델로 실패한 경우가 많았음
	• 넥슨은 플레이하면서 자연스럽게 얻는 보상(P&E)을 통해 지속 가능한 경제 모델을 실험 중

4. 거버넌스 & 수익 공유 ($NEXO 토큰 예상)
	• 게임 내 정책 & 업데이트에 커뮤니티가 직접 참여 가능
	• 토큰 보유자들은 생태계에서 발생하는 수익 일부를 공유할 가능성 있음
						`}
				</pre>

				<h3>토큰 분배 예상 비율</h3>
				<pre>
					{`1️⃣ 유저 보상 (게임 내 획득) → 50%
	• 게임을 플레이하면서 자연스럽게 토큰을 획득하는 구조
	• NFT 아이템, 퀘스트 보상, 거래 등을 통해 얻을 가능성이 큼

2️⃣ 개발팀 & 넥슨 → 20%
	• 넥슨이 프로젝트 운영 및 유지보수하는 비용
	• 게임 개발 및 Web3 인프라 확장을 위한 리소스

3️⃣ 투자자 & 초기 파트너 → 15%
	• 초기 투자자, 게임 개발 파트너 및 블록체인 파트너들에게 배분
	• Web3 프로젝트에서는 벤처캐피털(VC) 등이 초반 투자자로 참여하는 경우가 많음

4️⃣ 커뮤니티 & 거버넌스 → 10%
	• DAO 운영, 거버넌스 투표 참여 보상 등
	• 커뮤니티 활동 & 게임 내 경제 모델 유지에 기여하는 유저들에게 지급될 가능성 있음

5️⃣ 마케팅 & 생태계 확장 → 5%
	• Web3 게임의 초기 유저 확보를 위한 마케팅 비용
	• 크리에이터, 인플루언서, 스트리머 지원 등

(넥슨의 공식 발표는 아니고, 일반적인 Web3 게임 모델을 기반으로 한 예상 비율)
`}
				</pre>

				<h3>과~연?</h3>
				<pre>
					{`메이플스토리 유니버스는 성공할수 있을까?

활성화될 가능성이 높은 이유
	1.	기존 IP의 강력한 유저 풀 → 신규 Web3 게임보다 훨씬 높은 초기 유저 유입 가능
	2.	넥슨의 대규모 개발 리소스 → 전통 게임사들이 Web3를 실험하는 대표 사례
	3.	P2W 방지 & 지속 가능한 경제 모델 실험 → Web3 게임 실패 사례에서 배움

실패할 가능성이 있는 이유
	1.	Web3 게임의 성공 사례 부족 → 기존 블록체인 게임 대부분이 실패
	2.	메이플스토리 원작 유저 반발 가능성 → Web3 모델이 기존 유저들에게 낯설 수 있음
	3.	토큰 가격 변동성 문제 → 게임 내 경제 시스템이 Web3 요소로 인해 불안정해질 위험

--------------------------------------------------

결론
- Web3 게임이 성공하기 어려운 시장이지만, 넥슨의 IP & 리소스를 고려하면 기대해볼 만함?
- NFT & 토큰 기반 경제 모델을 실험하는 새로운 시도!
- P2W 없이 지속 가능한 Web3 게임 경제를 만들 수 있을지 주목할 필요는 있음

(이미지 설명)
`}
				</pre>
			</div>
		),
	},
	{
		id: 24,
		date: '13/03/2025 (3)',
		tags: ['Coin', 'Token', 'Tokenomics', 'Dapp', 'Blockchain'],
		title: 'DApp, and Coin vs Token',
		content: (
			<div>
				<h3>DApp</h3>
				<pre>
					{`- DApp(Decentralized Application)은 탈중앙화 애플리케이션
- 이더리움, 큐텀, 이오스와 같은 스마트 컨트랙트를 지원하는 블록체인 플랫폼 위에서 작동
- 블록체인 기술의 특징을 활용하여 중앙 서버가 필요 없는 구조
- 스마트 컨트랙트를 통해 특정 조건이 충족되면 자동으로 실행됨
`}
				</pre>

				<h3>DApp의 특징</h3>
				<pre>
					{`- 탈중앙화
DApp은 중앙 서버를 사용하지 않고, 블록체인 네트워크에 데이터를 분산 저장
중앙 관리자의 개입 없이 데이터의 신뢰성과 안정성을 보장

- 위·변조 불가
블록체인의 특성상 데이터는 위·변조가 불가능
개인 정보는 암호화되거나 참조값으로 저장되므로, 보안성이 높고 무단 유출 위험이 적음

- 가동성
DApp은 분산된 네트워크를 기반으로 하기 때문에, 
일부 네트워크 장애가 발생하더라도 다른 노드를 통해 서비스를 계속 이용할 수 있음

- 토큰 이코노미
DApp은 자체 토큰을 발행하여 광고 대신 사용자에게 보상을 제공하는 등 독립적인 경제 생태계 구축 가능
`}
				</pre>

				<h3>Token VS Coin</h3>
				<pre>{`DApp의 암호화폐를 토큰(Token)이라고 부르며, 블록체인 네트워크의 기본 암호화폐인 코인과 구분!

Token :
	- 토큰 발행 방법 - 스마트 컨트랙트
	- 특정 플랫폼에서 특정 조건을 만족했을 때 토큰 전송
	- e.g. 게임 재화 등

Coin : 
	- 블록체인 네트워크에서 발행
	- 채굴 시 리워드
				`}</pre>

				<h3>토큰 이코노미</h3>
				<pre>{`토큰 이코노미는 특정한 목표 행동을 끌어내기 위해, 
목표 행동을 수행했을 때마다 ‘토큰’을 보수로 주고, 
그 토큰을 유/무형의 가치와 교환함으로써 목표 행동을 강화하는 방법

토큰 이코노미 & 크립토 이코노미 차이점
	- "토큰 이코노미(Token Economy)"는 행동심리학에서 특정 행동을 강화하기 위한 보상 시스템을 의미
	- "크립토 이코노미(Crypto Economy)"는 블록체인과 암호화폐를 활용한 경제 시스템을 의미하며, 토큰 이코노미보다 넓은 개념
	- 블록체인 기반 토큰 이코노미는 크립토 이코노미의 일부로 볼 수 있습니다.

토큰 이코노미의 3요소
	- 토큰(Tokens) : 교환될 수 있는 물건이나 상징
	- 강화제(Back-up Reinforcers) : 장난감 또는 놀이공원 (특정 목표 행동을 하도록 보상을 마련)
	- 특정 목표 행동(specified target behavior) : 수학 문제를 풀고 성정 향상 (수행해야 하는 바람직한 행동)
				`}</pre>

				<h3>블록체인 토큰 이코노미의 목적</h3>
				<pre>{`블록체인 생태계에서 토큰 이코노미의 목적은 인센티브를 통한 네트워크의 확장입니다.

블록체인 네트워크는 참여자가 많아질수록 네트워크의 사용성과 범용성이 더 좋아집니다.
따라서 네트워크 참여자가 많아져 생태계가 활성화되면 토큰 자체의 가격이 올라
생태계 참여자는 더 많은 인센티브를 얻게 됩니다.
				`}</pre>

				<h3>블록체인 토큰 이코노미를 설계할 때 고려해야 할 것</h3>
				<pre>{`	- 보상(토큰)은 어떤 기준으로 어떤 참여자에게 줄 것인가?
	- 어떻게 토큰이 가치를 갖게 할 것인가?
	- 사람들이 토큰을 보유해야 할 유인은 무엇인가?
	- 토큰의 발행량은 얼마로 하고 어떻게 분배할 것인가?
	- 네트워크의 성장과 토큰의 가치 상승을 어떻게 연동할 것인가?
	- 토큰의 가격 변동성은 어떻게 해결할 것인가?
				`}</pre>
			</div>
		),
	},
	{
		id: 25,
		date: '14/03/2025',
		tags: ['BIP-32', 'BIP-44', 'HD wallet', 'Wallet', 'Blockchain'],
		title: 'Wallet',
		content: (
			<div>
				<h3>비결정적 월렛(Non-Deterministic Wallet)</h3>
				<pre>
					{`각 키가 독립적으로 생성되며, 시드(Seed) 없이 비밀키를 무작위로 생성하는 방식

- 동일한 개인키를 다시 생성할 수 없기 때문에 주소를 재사용하지 않는 것이 일반적
- 개별 키를 모두 백업해야 하는 불편함이 있음
- 트랜잭션을 생성할 때마다 새로운 비대칭키를 생성해 지갑에 저장해야 함

실수로 지갑 데이터를 분실할 경우,
해당 비밀키를 통해 생성된 주소에 들어있던 코인과 해당 주소로 생성한 스마트 컨트랙트에 접근하지 못하게 됨

=> 비결정적 키 생성 방식을 사용하는 지갑은 데이터를 자주 백업해야 하므로 관리 측면에서 불편함이 있음
`}
				</pre>

				<h3>결정적 월렛(Deterministic Wallet)</h3>
				<pre>
					{`하나의 시드(Seed)에서 모든 비밀키를 파생하며, 각 비밀키는 시드와 특정 인덱스(Index)의 조합으로 결정됨

- 시드만 알고 있다면 같은 키를 다시 생성할 수 있으므로 백업과 복구가 용이함
- 모든 비밀키는 "미리 결정된 값"을 가짐
- 이를 통해 사용자는 하나의 시드만 관리하면 전체 지갑을 복구할 수 있음
- 지갑 데이터가 손상되거나 삭제되더라도, 시드 키만 보관하고 있으면 동일한 키를 다시 생성하여 자금을 복구할 수 있음
`}
				</pre>

				<h3>HD 월렛(Hierarchical Deterministic Wallet, 계층적 결정적 지갑)</h3>
				<pre>
					{`결정적 지갑의 대표적인 예시로, BIP-32에서 제안되고, BIP-44에서 개선된 비트코인 표준
계층 구조(Tree Structure)를 활용하여 키를 체계적으로 관리하는 방식
`}
				</pre>

				<h3>HD 월렛의 특징</h3>
				<pre>
					{`- 결정적(Deterministic) 특성
	* 하나의 시드(seed)만 관리하면 모든 비밀키를 유도할 수 있어 백업 및 복구가 용이함
	* 비밀키를 개별적으로 관리할 필요 없음

- 계층적(Hierarchical) 구조
	* HD 월렛의 주소는 트리(Tree) 구조를 통해 생성됩니다.
	* 상위 키(부모 키)에서 하위 키(자식 키)를 유도하는 방식으로 확장됨
	* 각 노드의 인덱스와 시드를 결합하여 비밀키를 생성하므로, 체계적인 키 관리가 가능합니다.

- 유도 가능한 키 체계
	* 부모 키에서 자식 키를 유도할 수 있으며, BIP-44에서는 표준화된 경로(Path)를 정의하여 특정 코인과 계정에 맞는 키를 생성할 수 있음
	* 이러한 구조 덕분에 여러 개의 주소를 생성하더라도, 하나의 시드만으로 전체 지갑을 복구할 수 있음
`}
				</pre>

				<h3>HD Wallet 계정 생성 주요 개념</h3>
				<pre>
					{`HD 월렛에서 주소와 비밀키를 생성하기 위해서는 시드(seed)와 인덱스(index)만 알면 됩니다
인덱스는 계층적 트리 구조의 루트(root)부터 현재 노드까지의 경로를 의미합니다

시드(seed)
	- HD 월렛은 암호학적으로 안전한 무작위 숫자에서 니모닉 연상 단어(Mnemonic Code Words)를 생성한 후,
	  이를 바탕으로 HD 지갑의 시드를 생성합니다.
	- 시드는 지갑의 "루트 키" 역할을 하며, 이를 통해 모든 하위 키가 결정적으로 파생됩니다.
	- 니모닉 연상 단어만 알고 있다면, 언제 어디서나 지갑을 복구할 수 있습니다.

경로(path)
	- HD Wallet의 키 경로(path)는 계층적 구조를 따르며, 트리 구조에서 각 키의 위치를 나타내는 규칙입니다.
	- 각 트리 레벨은 슬래시(/)로 구분되며, 경로를 따라 체계적으로 키를 관리할 수 있습니다.

구조:
	m/0 → 마스터 비밀키의 첫 번째 자식 비밀키
	M/0 → 첫 번째 자식 공개키
	m/0/2 → 마스터 비밀키의 첫 번째 자식의 두 번째 자식 비밀키 (순차적 구조)
`}
				</pre>

				<h3>BIP-32</h3>
				<pre>{`- HD 지갑을 처음 제안한 비트코인 표준
- 결정적 지갑을 계층적으로 관리할 수 있도록 설계하여, 무한히 확장 가능한 비밀키 생성 구조를 제안
`}</pre>

				<h3>BIP-44</h3>
				<pre>{`- BIP-32를 확장하여, 여러 개의 계정을 관리할 수 있도록 개선된 표준
- HD Wallet이 여러 개의 계정을 논리적으로 구분할 수 있도록 설계됨
- SLIP-0044 문서를 기반으로 특정 코인에 맞는 계정을 구분할 수 있음

* 목적(Purpose): 
	BIP-44 기반 지갑에서는 이 값이 44로 설정됩니다.
* 코인 종류(Coin Type): 
	어떤 종류의 코인인지 나타냅니다. 
	SLIP-0044 문서에서 각 코인의 종류와 할당된 번호를 확인할 수 있습니다.
* 계정(Account):
	사용자는 지갑을 논리적인 계정으로 나눌 수 있습니다.
	e.g. m/44'/0'/0'과 m/44'/0'/1'은 하나의 HD 지갑에서 2개의 비트코인 계정을 의미합니다.
* 잔액 계정 여부(Change Addresses):
	하위 트리에서 입금 주소인지 잔액 주소(변경 주소)인지를 구분합니다.
	잔액 주소(변경 주소)일 경우 1, 입금 주소일 경우 0을 사용합니다.
	이더리움은 어카운트 기반이므로, 일반적으로 이 값은 0입니다.
* 사용 가능한 주소:
	입금 주소 또는 잔액 주소를 나타냅니다.
* 
M/44'/60'/0'/0/2 : 이더리움 계정에 대한 세 번째 수신 공개키
M/44'/0'/3'/1/14 : 4번째 비트코인 계정의 15번째 주소 변경 공개키
M/44'/118'/0'/0/1 : 트랜잭션 서명을 위한 아톰 코인 메인 계정의 두 번째 개인키
`}</pre>
			</div>
		),
	},
	{
		id: 26,
		date: '14/03/2025',
		tags: ['PBKDF2', 'Entropy', 'Key Stretching', 'Wallet', 'Blockchain'],
		title: 'Mnemonic',
		content: (
			<div>
				<h3>Mnemonic</h3>
				<pre>
					{`BIP-39 표준에서 제안된 방식으로, 난수를 12개 또는 24개의 영어 단어로 변환한 시드 복구 방​법

HD 월렛 : 시드 키를 가지고 지갑과 지갑에 있는 비밀키와 주소를 복구하고 백업
니모닉 월렛 : 시드 키 대신, 시드 키를 생성하는 데 사용하는 니모닉 연상 단어를 사용해 지갑을 관리
`}
				</pre>

				<h3>니모닉 코드와 시드 생성 9단계</h3>
				<pre>
					{`1. 128bit 또는 256bit 길이의 난수를 생성합니다.
2. 난수를 SHA-256 알고리즘으로 해싱하고, 해시값에서 (시드 키의 길이) / 32bit 만큼을 떼어냅니다.
	* 체크섬(Checksum): 어떤 입력의 데이터에 오류가 존재하는지 확인하기 위한 검사용 데이터
	* 가령, 난수의 길이가 128bit라면, 해시값에서 128 / 32bit = 4bit를 앞에서부터 떼어내어 체크섬으로 만듭니다.
3. 체크섬을 난수의 뒤에 붙입니다.
4. 체크섬을 붙인 난수를 11bit 단위로 잘라냅니다.
5. 각 11bit의 단어를 사전에 정의된 단어로 치환합니다.
6. 각 11bit의 순서를 유지하여 일련의 니모닉 코드를 만듭니다.
	* 위의 과정을 통해 128~256bit 길이의 엔트로피를 표현하는 니모닉 코드가 생성되었습니다.
	* 이제 이 엔트로피를 키 스트레칭 함수 PBKDF2를 사용하여 더 긴 (512bit) 시드를 파생시킵니다.
	* 키 스트레칭 함수에는 니모닉 코드와 솔트(salt)라는 두 가지 파라미터를 넣습니다.
7. PBKDF2 키 스트레칭 함수의 첫 번째 인자는 6단계에서 생성된 니모닉 코드입니다.
8. PBKDF2 키 스트레칭 함수의 두 번째 인자는 솔트(salt)입니다. 
	* 솔트는 'mnemonic' 문자열과 사용자가 입력한 패스프레이즈(passphrase)를 조합한 값입니다.
9. PBKDF2는 최종 출력으로 512비트 값을 만드는 HMAC-SHA512 알고리즘을 사용합니다. 
	2048 해시 라운드를 적용하여 니모닉과 솔트 파라미터를 확장하며, 이 결과로 나온 512비트 값이 시드(seed)입니다.
`}
				</pre>

				<h3>엔트로피(Entropy)</h3>
				<pre>
					{`엔트로피(Entropy)는 시스템의 무작위성(randomness)을 측정하는 개념입니다.
	•	암호학에서는 비밀번호, 시드(seed), 키를 예측할 수 없도록 하기 위해 엔트로피가 높아야 합니다.
	•	엔트로피가 높을수록 보안성이 증가하고, 낮을수록 예측이 쉬워져 공격받기 쉬움.

Mnemonic (니모닉)에서 엔트로피 역할
	•	니모닉 코드(1224 단어)를 만들기 위해 128256비트의 무작위 엔트로피를 생성.
	•	엔트로피가 높아질수록 니모닉의 강도(비트 수) 증가
	•	128-bit entropy → 12단어 니모닉
	•	256-bit entropy → 24단어 니모닉 (더 안전함)
`}
				</pre>

				<h3>키 스트레칭(Key Stretching)</h3>
				<pre>
					{`키 스트레칭(Key Stretching)은 짧고 취약한 키(비밀번호, 시드 등)를 더 강한 키로 변환하는 과정입니다.
	•	취약한 키를 공격(예: 무차별 대입 공격)으로부터 보호하기 위해 사용됨.
	•	실행 속도를 일부러 느리게 만들어 공격을 어렵게 함.

예제: Key Stretching 과정
	1.	사용자가 비밀번호(password123)를 입력함.
	2.	PBKDF2, bcrypt, scrypt 같은 키 스트레칭 알고리즘을 사용하여 더 강한 키(512bit)로 변환.
	3.	결과적으로 해커가 빠르게 해독하는 것이 어려워짐.
`}
				</pre>

				<h3>PBKDF2란? (Password-Based Key Derivation Function 2)</h3>
				<pre>
					{`PBKDF2는 대표적인 키 스트레칭 알고리즘으로, 여러 번 반복 연산을 수행해 키를 안전하게 파생하는 함수입니다.

📌 PBKDF2의 원리
	•	입력값: 비밀번호 + 솔트(Salt)
	•	해싱 함수 사용 (HMAC-SHA256 or HMAC-SHA512)
	•	여러 번 반복(예: 100,000번 이상 해시 계산)하여 공격을 어렵게 만듦.
`}
				</pre>

				<h3> PBKDF2 예제 (Node.js)</h3>
				<SyntaxHighlighter language='solidity' style={vscDarkPlus}>
					{`const crypto = require('crypto');

const password = 'user_password';
const salt = crypto.randomBytes(16).toString('hex'); // 16바이트 솔트 생성
const iterations = 100000; // 반복 횟수 (높을수록 안전하지만 느려짐)
const keyLength = 64; // 키 길이 (512비트 = 64바이트)

crypto.pbkdf2(password, salt, iterations, keyLength, 'sha512', (err, derivedKey) => {
    if (err) throw err;
    console.log("Derived Key:", derivedKey.toString('hex'));
});`}
				</SyntaxHighlighter>
				<pre>
					{`🛠 PBKDF2 특징
	•	반복 횟수(Iterations): 많이 설정할수록 더 안전하지만 성능이 낮아짐.
	•	솔트(Salt): 같은 비밀번호라도 다르게 변환되도록 추가된 난수값.
	•	HMAC 해시 함수 사용: SHA256, SHA512 등 사용.`}
				</pre>

				<h3>🛠 블록체인에서 PBKDF2 사용 예시</h3>
				<pre>
					{`니모닉(Mnemonic) → 시드(Seed) 변환 과정
	1.	128~256비트의 엔트로피 생성
	2.	니모닉(Mnemonic) 단어로 변환 (BIP39)
	3.	PBKDF2 적용 (PBKDF2-HMAC-SHA512)
		•	2048번 반복 수행 → 512비트 시드(Seed) 생성
	4.	생성된 시드를 사용해 HD Wallet 생성 (BIP32)

✅ 결과적으로, 니모닉 → 시드 변환 과정에서 PBKDF2가 사용됨! 🚀
`}
				</pre>
			</div>
		),
	},
]
